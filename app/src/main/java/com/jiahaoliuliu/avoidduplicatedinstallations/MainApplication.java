package com.jiahaoliuliu.avoidduplicatedinstallations;

import android.app.Application;
import android.content.Context;
import android.provider.Settings;
import android.telephony.TelephonyManager;
import android.util.Log;

import com.parse.Parse;
import com.parse.ParseException;
import com.parse.ParseInstallation;
import com.parse.ParsePush;
import com.parse.SaveCallback;
import com.parse.SendCallback;

import org.json.JSONObject;

import java.util.UUID;

/**
 * Created by Jiahao on 6/23/15.
 */
public class MainApplication extends Application {
    private static final String TAG = "MainApplication";
    private static final String PARSE_INSTALLATION_TABLE_COLUMN_UNIQUE_ID = "uniqueId";

    private volatile UUID mUuid;
    private Object lock = new Object();
    private Preferences mPreferences;

    @Override
    public void onCreate() {
        super.onCreate();

        mPreferences = new Preferences(this);

        // Initialize Parse
        Parse.initialize(this, APIKeys.APPLICATION_ID, APIKeys.CLIENT_ID);
        ParsePush.subscribeInBackground("", new SaveCallback() {
            @Override
            public void done(ParseException e) {
                if (e == null) {
                    Log.d(TAG, "successfully subscribed to the broadcast channel.");
                } else {
                    Log.e(TAG, "failed to subscribe for push", e);
                }
            }
        });

        // Update the installation id
        ParseInstallation installation = ParseInstallation.getCurrentInstallation();
        installation.put(PARSE_INSTALLATION_TABLE_COLUMN_UNIQUE_ID, getUuid().toString());
        installation.saveInBackground(new SaveCallback() {
            @Override
            public void done(ParseException e) {
                if (e == null) {
                    Log.v(TAG, "Installation updated correctly");
                } else {
                    Log.e(TAG, "There was some problem related with the installation", e);
                }

                // Send invisible push notification after the
                //sendInvisiblePushNotification();
            }
        });
    }

    private UUID getUuid() {
        if (mUuid == null) {
            generateUUID();
        }

        return mUuid;
    }

    /**
     * Based on the code in StackOverFlow:
     * http://stackoverflow.com/questions/2785485/is-there-a-unique-android-device-id Returns a
     * unique UUID for the current android device. As with all UUIDs, this unique ID is
     * "very highly likely" to be unique across all Android devices. Much more so than ANDROID_ID
     * is.
     *
     * The UUID is generated by using ANDROID_ID as the base key if appropriate, falling back on
     * TelephonyManager.getDeviceID() if ANDROID_ID is known to be incorrect, and finally falling
     * back on a random UUID that's persisted to SharedPreferences if getDeviceID() does not return
     * a usable value.
     *
     * In some rare circumstances, this ID may change. In particular, if the device is factory reset
     * a new device ID may be generated. In addition, if a user upgrades their phone from certain
     * buggy implementations of Android 2.2 to a newer, non-buggy version of Android, the device ID
     * may change. Or, if a user uninstalls your app on a device that has neither a proper Android
     * ID nor a Device ID, this ID may change on reinstallation.
     *
     * Note that if the code falls back on using TelephonyManager.getDeviceId(), the resulting ID
     * will NOT change after a factory reset. Something to be aware of.
     *
     * Works around a bug in Android 2.2 for many devices when using ANDROID_ID directly.
     *
     * @see http://code.google.com/p/android/issues/detail?id=10603
     *
     * @return a UUID that may be used to uniquely identify your device for most purposes.
     */
    private void generateUUID() {
        // If the uuid has not been generated before
        synchronized (lock) {
            // It could be that the UUID has been generated by other threads
            // that has the lock. Check it again
            if (mUuid == null) {
                final String id = mPreferences.get(Preferences.StringId.UUID);
                if (id != null) {
                    // Use the ids previously computed and stored in the
                    // prefs file
                    mUuid = UUID.fromString(id);
                } else {
                    final String androidId = Settings.Secure.getString(
                            getContentResolver(), Settings.Secure.ANDROID_ID);
                    // Use the Android ID unless it's broken, in which case
                    // fallback on deviceId,
                    // unless it's not available, then fallback on a random
                    // number which we store to a prefs file
                    if (!"9774d56d682e549c".equals(androidId)) {
                        mUuid = UUID.nameUUIDFromBytes(androidId.getBytes());
                    } else {
                        final String deviceId = ((TelephonyManager) getSystemService(Context.TELEPHONY_SERVICE)).getDeviceId();
                        mUuid = deviceId != null ? UUID.nameUUIDFromBytes(deviceId.getBytes())
                                : UUID.randomUUID();
                    }
                    // Write the value out to the prefs file
                    mPreferences.set(Preferences.StringId.UUID, mUuid.toString());
                }
            }
        }
    }

    private void sendInvisiblePushNotification() {
        ParsePush parsePush = new ParsePush();
        parsePush.setChannel("");
        parsePush.setData(new JSONObject());
        parsePush.sendInBackground(new SendCallback() {
            @Override
            public void done(ParseException e) {
                if (e == null) {
                    Log.v(TAG, "Push notification sent correctly");
                } else {
                    Log.e(TAG, "Error sending push notification " + e.getCode(), e);
                }
            }
        });
    }
}
